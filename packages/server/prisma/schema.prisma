generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Setup {
  id        Int     @id @default(1)
  step      Int     @default(1)
  completed Boolean @default(false)
}

model User {
  id                            String                   @id @default(cuid())
  name                          String
  displayName                   String
  email                         String                   @unique
  emailVerified                 Boolean                  @default(false)
  password                      String
  // Avatar
  avatar                        Media?                   @relation("UserAvatar", fields: [avatarId], references: [id])
  avatarId                      String?
  // Order of user campaigns
  campaignOrder                 String[]                 @default([])
  // DateTime
  createdAt                     DateTime                 @default(now())
  updatedAt                     DateTime                 @default(now()) @updatedAt
  // Refresh Tokens
  refreshTokens                 RefreshToken[]           @relation("UserRefreshTokens")
  // Maps
  maps                          Map[]                    @relation("UserMaps")
  // Tokens
  tokens                        Token[]                  @relation("UserTokens")
  // Media
  media                         Media[]                  @relation("UserMedia")
  // Campaigns
  campaignsCreated              Campaign[]               @relation("UserCampaigns")
  campaignsMember               CampaignMember[]         @relation("UserCampaignsMember")
  // Player Characters
  createdPlayerCharacters       PlayerCharacter[]        @relation("CreatedPlayerCharacters")
  controlledPlayerCharacters    PlayerCharacter[]        @relation("ControlledPlayerCharacters")
  // Non Player Characters
  createdNonPlayerCharacters    NonPlayerCharacter[]     @relation("CreatedNonPlayerCharacters")
  controlledNonPlayerCharacters NonPlayerCharacter[]     @relation("ControlledNonPlayerCharacters")
  // Generic tokens
  emailVerificationTokens       EmailVerificationToken[] @relation("UserEmailVerificationTokens")
  passwordResetTokens           PasswordResetToken[]     @relation("UserPasswordResetTokens")
  campaignInvites               CampaignInvite[]         @relation("UserCampaignInvites")
}

model RefreshToken {
  id        String   @id @default(cuid())
  value     String   @unique
  // DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt
  // User
  user      User     @relation("UserRefreshTokens", fields: [userId], references: [id])
  userId    String
}

model EmailVerificationToken {
  id        String   @id @default(cuid())
  value     String   @unique
  // DateTime
  createdAt DateTime @default(now())
  // User
  user      User     @relation("UserEmailVerificationTokens", fields: [userId], references: [id])
  userId    String
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  value     String   @unique
  // DateTime
  createdAt DateTime @default(now())
  // User
  user      User     @relation("UserPasswordResetTokens", fields: [userId], references: [id])
  userId    String
}

model CampaignInvite {
  id         String   @id @default(cuid())
  email      String
  value      String   @unique
  // DateTime
  createdAt  DateTime @default(now())
  // User
  user       User?    @relation("UserCampaignInvites", fields: [userId], references: [id])
  userId     String?
  // Campaign
  campaign   Campaign @relation("CampaignInvites", fields: [campaignId], references: [id])
  campaignId String
}

model Campaign {
  id                  String               @id @default(cuid())
  name                String
  // DateTime
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @default(now()) @updatedAt
  // Maps
  maps                Map[]                @relation("CampaignMaps")
  // Members
  members             CampaignMember[]     @relation("CampaignMembers")
  // Player Characters
  playerCharacters    PlayerCharacter[]    @relation("CampaignPlayerCharacters")
  // Non Player Characters
  nonPlayerCharacters NonPlayerCharacter[] @relation("CampaignNonPlayerCharacters")
  // Created by
  createdBy           User                 @relation("UserCampaigns", fields: [createdById], references: [id])
  createdById         String
  // Invites
  invites             CampaignInvite[]     @relation("CampaignInvites")
}

enum CampaignMemberRole {
  GAME_MASTER
  PLAYER
}

model CampaignMember {
  id         String             @id @default(cuid())
  role       CampaignMemberRole @default(PLAYER)
  // User
  user       User               @relation("UserCampaignsMember", fields: [userId], references: [id])
  userId     String
  // Campaign
  campaign   Campaign           @relation("CampaignMembers", fields: [campaignId], references: [id])
  campaignId String
  // DateTime
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @default(now()) @updatedAt
}

model Map {
  id              String   @id @default(cuid())
  name            String
  // Order
  order           Int?     @default(autoincrement())
  // DateTime
  createdAt       DateTime @default(now())
  updatedAt       DateTime @default(now()) @updatedAt
  // Tokens
  tokens          Token[]  @relation("MapTokens")
  // Media
  media           Media[]  @relation("MapMedia")
  selectedMediaId String?
  // Campaign
  campaign        Campaign @relation("CampaignMaps", fields: [campaignId], references: [id])
  campaignId      String
  // Created by
  createdBy       User     @relation("UserMaps", fields: [createdById], references: [id])
  createdById     String
}

model Movement {
  id                String           @id @default(cuid())
  burrow            Int              @default(0)
  climb             Int              @default(0)
  fly               Int              @default(0)
  hover             Boolean          @default(false)
  swim              Int              @default(0)
  walk              Int              @default(30)
  // Player Character
  playerCharacter   PlayerCharacter? @relation("PlayerCharacterMovement", fields: [playerCharacterId], references: [id])
  playerCharacterId String?          @unique
}

model HitPoints {
  id                   String              @id @default(cuid())
  current              Int                 @default(10)
  maximum              Int                 @default(10)
  temporary            Int                 @default(0)
  // certain effects change max hp temporarily. if this value is non-null use it instead of maximum in places where maximum would be used
  adjustedMaximum      Int?
  formula              String              @default("1d10")
  // Player Character
  playerCharacter      PlayerCharacter?    @relation("PlayerCharacterHitPoints", fields: [playerCharacterId], references: [id])
  playerCharacterId    String?             @unique
  // Non Player Character
  nonPlayerCharacter   NonPlayerCharacter? @relation("NonPlayerCharacterHitPoints", fields: [nonPlayerCharacterId], references: [id])
  nonPlayerCharacterId String?             @unique
}

model ArmorClass {
  id                String           @id @default(cuid())
  value             Int              @default(10)
  description       String           @default("")
  // Player Character
  playerCharacter   PlayerCharacter? @relation("PlayerCharacterArmorClass", fields: [playerCharacterId], references: [id])
  playerCharacterId String?          @unique
}

model Senses {
  id                String           @id @default(cuid())
  blindsight        Int              @default(0)
  darkvision        Int              @default(0)
  tremorsense       Int              @default(0)
  truesight         Int              @default(0)
  // Player Character
  playerCharacter   PlayerCharacter? @relation("PlayerCharacterSenses", fields: [playerCharacterId], references: [id])
  playerCharacterId String?          @unique
}

model Ability {
  id                String           @id @default(cuid())
  name              String
  shortName         String
  score             Int              @default(10)
  modifier          Int              @default(0)
  save              Int              @default(0)
  // Skills
  skills            Skill[]          @relation("AbilitySkills")
  // Player Character
  playerCharacter   PlayerCharacter? @relation("PlayerCharacterAbilities", fields: [playerCharacterId], references: [id])
  playerCharacterId String?
}

model Skill {
  id                String           @id @default(cuid())
  name              String
  level             Int              @default(0)
  bonus             Int              @default(0)
  // Ability
  ability           Ability          @relation("AbilitySkills", fields: [abilityId], references: [id])
  abilityId         String
  // Player Character
  playerCharacter   PlayerCharacter? @relation("PlayerCharacterSkills", fields: [playerCharacterId], references: [id])
  playerCharacterId String?
}

model Currencies {
  id                String          @id @default(cuid())
  copper            Int             @default(0)
  silver            Int             @default(0)
  gold              Int             @default(0)
  electrum          Int             @default(0)
  platinum          Int             @default(0)
  // Player Character
  playerCharacter   PlayerCharacter @relation("PlayerCharacterCurrencies", fields: [playerCharacterId], references: [id])
  playerCharacterId String          @unique
}

model PlayerCharacter {
  id              String      @id @default(cuid())
  name            String
  size            String      @default("Medium")
  alignment       String      @default("Neutral")
  // DateTime
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @default(now()) @updatedAt
  // Armor Class
  armorClass      ArmorClass? @relation("PlayerCharacterArmorClass")
  // Hit Points
  hitPoints       HitPoints?  @relation("PlayerCharacterHitPoints")
  // Movement
  movement        Movement?   @relation("PlayerCharacterMovement")
  // Senses
  senses          Senses?     @relation("PlayerCharacterSenses")
  // Currencies
  currencies      Currencies? @relation("PlayerCharacterCurrencies")
  // Abilities
  abilities       Ability[]   @relation("PlayerCharacterAbilities")
  // Skills
  skills          Skill[]     @relation("PlayerCharacterSkills")
  // Tokens
  tokens          Token[]     @relation("PlayerCharacterTokens")
  // Media
  media           Media[]     @relation("PlayerCharacterMedia")
  selectedMediaId String?
  // Created by
  createdBy       User        @relation("CreatedPlayerCharacters", fields: [createdById], references: [id])
  createdById     String
  // Controlled by
  controlledBy    User[]      @relation("ControlledPlayerCharacters")
  // Campaign
  campaign        Campaign    @relation("CampaignPlayerCharacters", fields: [campaignId], references: [id])
  campaignId      String
}

// TODO: discussion about monster model!
// this proposed monster schema assumes the data is static and does not
// do any special calculations. The reason we'd want this method is that
// the VTT is not a monster builder; it should not be opinionated about what the
// stats _should_ be because we might have used some DM discretion when creating the monster.
// If we assume that, then all of the data in the DB is treated as given.
//
// While the minimum needed for a stat block is the text description, certain fields
// are added as annotated values to enable additional functionality you would need when
// running a game, such as every attack and actions being able to have a "Targeting" struct
// attached that says how the ability should render a targeting widget on the VTT
// (can't tell you how many times I wish i could click "cast fireball" and have it give me
// a 30 ft. radius circle template to place on the grid instead of drawing it, or
// click "breath weapon" and have it put a cone centered at the token)

// generic model
// the intent behind this model is to store info for arbitrary actions
// allowing the VTT to go in to an "ability targeting mode" that lets the DM or player draw a shape
// or click on targets based on what the skill allows
model Targeting {
  id                   String                @id @default(cuid())
  // this should probably be enumerated? I don't know how to do that in prisma, or is it enforced client side?
  // can add more enum types on the client side i guess?
  type                 TargetingRange        @default(MELEE)
  numberOfTargets      Int? // used by melee/ranged single/multitarget attacks
  range                Int? // used by everything
  rangeFar             Int? // used by ranged attacks for dnd 5e
  radius               Int? // used for circles
  width                Int? // used for cubes, lines
  height               Int? // used for cubes
  // relationships
  // 5e action
  dnd5eAction          Dnd5eAction?          @relation("Dnd5eActionTargeting")
  // 5e trait
  dnd5eTrait           Dnd5eTrait?           @relation("Dnd5eTraitTargeting")
  // legendary action
  dnd5eLegendaryAction Dnd5eLegendaryAction? @relation("Dnd5eLegendaryActionTargeting")
  // 5e reaction
  dnd5eReaction        Dnd5eReaction?        @relation("Dnd5eReactionTargeting")
  // 5e spell
  dnd5eSpell           Dnd5eSpell?           @relation("Dnd5eSpellTargeting")
}

// oh we do have enum support
enum TargetingRange {
  MELEE
  RANGED
  AOE_CIRCLE
  AOE_CONE
  AOE_RECTANGLE
  AOE_LINE
}

// maybe this is a d20 stat? pathfinder uses the same data I think but has different rules
// about how they get computed
// we wouldn't reallllly care, unless the character sheets are dynamic
model Dnd5eStat {
  id                 String   @id @default(cuid())
  name               String
  shortName          String
  score              Int      @default(10)
  modifier           Int      @default(0)
  save               Int
  // bonus or penalty, for tracking stat changes or non-score-derived modifier
  scoreAdjustment    Int      @default(0)
  modifierAdjustment Int      @default(0)
  // attached to Dnd5eNpc
  dnd5eNpc           Dnd5eNpc @relation("Dnd5eNpcStats", fields: [dnd5eNpcId], references: [id])
  dnd5eNpcId         String   @unique
  // or a Dnd5ePlayerCharacter
}

// A skill in 5e is "atheltics, acrobatics, etc."
// generally skills are computed based on the stat modifier (computed from stat value)
// so we shouldn't need to store every skill, just the ones that are different
// than expected (through proficiency or some other source)
model Dnd5eSkill {
  id             String    @id @default(cuid())
  name           String
  shortName      String
  advantage      Boolean   @default(false)
  // I realized that a multiplier would be easier than booleans for half/full proficiency and expertise
  // half = +0.5 * pb, full = +1.0 * pb, expertise = +2.0 * pb
  profMultiplier Float     @default(0)
  // this plus the above multiplier should cover all cases
  // skills are always stat modifier + pb * profMultiplier + adjustment and the stat assignments are (almost always) static
  adjustment     Int       @default(0)
  // attached to NPC
  dnd5eNpc       Dnd5eNpc? @relation("Dnd5eNpcSkills", fields: [npcId], references: [id])
  npcId          String?
}

model Dnd5eArmorClass {
  id          String   @id @default(cuid())
  value       Int      @default(10)
  description String   @default("")
  // track temporary AC changes, specificallly calling this "adjustment" to distinguish between modifier
  // and temporary VTT overrides
  adjustment  Int      @default(0)
  // 5e Non Player Character
  dnd5eNpc    Dnd5eNpc @relation("Dnd5eNpcArmorClass", fields: [npcId], references: [id])
  npcId       String   @unique
}

model Dnd5eMovement {
  id       String   @id @default(cuid())
  burrow   Int      @default(0)
  climb    Int      @default(0)
  fly      Int      @default(0)
  hover    Boolean  @default(false)
  swim     Int      @default(0)
  walk     Int      @default(30)
  // 5e NPC
  dnd5eNpc Dnd5eNpc @relation("Dnd5eNpcMovement", fields: [npcId], references: [id])
  npcId    String   @unique
}

// might need to adjust this later for dynamic lighting? that's a ways off yet
model Dnd5eSenses {
  id          String    @id @default(cuid())
  blindsight  Int       @default(0)
  darkvision  Int       @default(0)
  tremorsense Int       @default(0)
  truesight   Int       @default(0)
  // 5e Non Player Character
  dnd5eNpc    Dnd5eNpc? @relation("Dnd5eNpcSenses", fields: [npcId], references: [id])
  npcId       String?   @unique
}

// this might be overkill, but since some single actions have multiple damage types
// and effects, this seems like how we'd represent that
model Dnd5eDamage {
  id                   String                @id @default(cuid())
  // why a string?
  // the formula should be kept as a string in a valid parsable format (2d6+{str}) for example
  // this way the front end for the VTT doesn't have to think too much about it and it'll
  // automatically update if the underlying data changes
  // assuming the formula is parseable in a consistent format (and it should be) it'll work
  // with moderate effort on the front-end size to load/save data
  formula              String
  type                 String
  // this is used in a bunch of spots
  // this is only used by 5e stuff so the names are done accordingly
  dnd5eAction          Dnd5eAction?          @relation("ActionDamage", fields: [actionId], references: [id])
  actionId             String?
  // trait
  dnd5eTrait           Dnd5eTrait?           @relation("TraitDamage", fields: [traitId], references: [id])
  traitId              String?
  // legendary action
  dnd5eLegendaryAction Dnd5eLegendaryAction? @relation("LegendaryActionDamage", fields: [legendaryActionId], references: [id])
  legendaryActionId    String?
  // reaction
  dnd5eReaction        Dnd5eReaction?        @relation("ReactionDamage", fields: [reactionId], references: [id])
  reactionId           String?
  // spell
  dnd5eSpell           Dnd5eSpell?           @relation("SpellDamage", fields: [spellId], references: [id])
  spellId              String?
}

// now we're getting in to the weeds
model Dnd5eAction {
  id             String        @id @default(cuid())
  name           String
  description    String
  // technically, that's all that's required
  // however, we'd like to have some nice things
  // let's track damage
  // TODO: versatile weapons? uhh....
  damage         Dnd5eDamage[] @relation("ActionDamage")
  // see the note for Dnd5eDamage's formula field
  // these strings will be able to use plain numbers or text macros (e.g. {dc:str} for saveDc)
  attackModifier String?
  saveDc         String?
  // range
  targeting      Targeting     @relation("Dnd5eActionTargeting", fields: [targetingId], references: [id])
  targetingId    String        @unique
  // the following fields are for action status tracking in the combat tracker
  ready          Boolean       @default(true)
  recharge       String?
  useCount       Int           @default(0) // times used, this should be per combat
  useLimit       Int? // undef = infinity
  // this is a dnd rules flag for monster statblock display
  bonusAction    Boolean       @default(false)
  // linked to npc
  dnd5eNpc       Dnd5eNpc      @relation("Dnd5eNpcActions", fields: [npcId], references: [id])
  npcId          String
}

// traits are much like actions
// to the point where this model is only different in that it excludes recharge and bonus action info
// (traits can't do that)
// maybe this should be combined with action and a type field added? unsure what best practice would be
// maybe a composite type?
model Dnd5eTrait {
  id             String        @id @default(cuid())
  name           String
  description    String
  damage         Dnd5eDamage[] @relation("TraitDamage")
  attackModifier String?
  saveDc         String?
  // range
  targeting      Targeting     @relation("Dnd5eTraitTargeting", fields: [targetingId], references: [id])
  targetingId    String        @unique
  // the following fields are for action status tracking in the combat tracker
  useCount       Int           @default(0) // times used, this should be per combat
  useLimit       Int? // undef = infinity
  // attached to npc
  dnd5eNpc       Dnd5eNpc      @relation("Dnd5eNpcTraits", fields: [npcId], references: [id])
  npcId          String
}

model Dnd5eLegendaryAction {
  id             String        @id @default(cuid())
  name           String
  description    String
  actionCost     Int           @default(1)
  mythic         Boolean       @default(false)
  damage         Dnd5eDamage[] @relation("LegendaryActionDamage")
  attackModifier String?
  saveDc         String?
  // range
  targeting      Targeting     @relation("Dnd5eLegendaryActionTargeting", fields: [targetingId], references: [id])
  targetingId    String        @unique
  // linked to npc
  dnd5eNpc       Dnd5eNpc      @relation("Dnd5eNpcLegendaryActions", fields: [npcId], references: [id])
  npcId          String
}

// I'm not actually sure if a reaction can have limited uses but maybe?
// I'm not putting it in right now because I haven't seen it?
model Dnd5eReaction {
  id             String        @id @default(cuid())
  name           String
  description    String
  damage         Dnd5eDamage[] @relation("ReactionDamage")
  attackModifier String?
  saveDc         String?
  // range
  targeting      Targeting     @relation("Dnd5eReactionTargeting", fields: [targetingId], references: [id])
  targetingId    String        @unique
  // linked to npc
  dnd5eNpc       Dnd5eNpc      @relation("Dnd5eNpcReactions", fields: [npcId], references: [id])
  npcId          String
}

// the spells should really be put in a user-level library and then referenced by the spellcasting lists
// I don't quite know how to express that relationship right now
// like the spells belong to a User and then the spellcasting structs access that?
model Dnd5eSpell {
  id                      String                 @id @default(cuid())
  name                    String
  description             String
  level                   Int                    @default(0)
  classes                 String[]
  damage                  Dnd5eDamage[]          @relation("SpellDamage")
  // spells have targets too
  targeting               Targeting              @relation("Dnd5eSpellTargeting", fields: [targetingId], references: [id])
  targetingId             String                 @unique
  // so the spells are assigned to the spellcasting lists but they're not necessarily unique?
  // is this a many to many relationship
  dnd5eSlotSpellcasting   Dnd5eSlotSpellcasting? @relation("Dnd5eSlotSpellList", fields: [dnd5eSlotSpellcastingId], references: [id])
  dnd5eSlotSpellcastingId String?
  dnd5eInnateSpellList    Dnd5eInnateSpellList?  @relation("Dnd5eInnateSpellList", fields: [dnd5eInnateSpellListId], references: [id])
  dnd5eInnateSpellListId  String?
}

model Dnd5eSlotSpellcasting {
  id          String       @id @default(cuid())
  // ui should sort slots into the proper slots
  spellsKnown Dnd5eSpell[] @relation("Dnd5eSlotSpellList")
  // ... i don't really want to write out every spell slot level but we could
  slots       Int[]
  slotsUsed   Int[]
  // npc link
  dnd5eNpc    Dnd5eNpc     @relation("Dnd5eSlotSpellcasting", fields: [npcId], references: [id])
  npcId       String       @unique
}

model Dnd5eInnateSpellList {
  id       String       @id @default(cuid())
  spells   Dnd5eSpell[] @relation("Dnd5eInnateSpellList")
  count    Int          @default(1)
  // could be enumerated but you know how users are
  rate     String       @default("Long Rest")
  used     Int          @default(0)
  // npc ref
  dnd5eNpc Dnd5eNpc?    @relation("Dnd5eInnateSpellLists", fields: [npcId], references: [id])
  npcId    String?
}

// I think the distinction between PC and NPC here is that a PC has a character sheet attached
// and a NPC has monster stat block formatting. Not all NPCs are monsters, and not all PCs
// are actually PCs.
model Dnd5eNpc {
  id                   String                 @id @default(cuid())
  size                 String                 @default("Medium")
  alignment            String                 @default("Neutral")
  challenge            String                 @default("0")
  // default prof bonus is actually 2, CR0 is +2 or less
  // the proficiency bonus should be based on CR but sometimes it's not
  proficiency          Int                    @default(2)
  // DateTime
  createdAt            DateTime               @default(now())
  updatedAt            DateTime               @default(now()) @updatedAt
  // Stats
  stats                Dnd5eStat[]            @relation("Dnd5eNpcStats")
  // Skills
  skills               Dnd5eSkill[]           @relation("Dnd5eNpcSkills")
  // Armor Class, required, everything needs it in Dnd
  armorClass           Dnd5eArmorClass?       @relation("Dnd5eNpcArmorClass")
  // Movement, also required
  movement             Dnd5eMovement?         @relation("Dnd5eNpcMovement")
  // Senses, required b/c passive perception
  senses               Dnd5eSenses?           @relation("Dnd5eNpcSenses")
  // Actions
  actions              Dnd5eAction[]          @relation("Dnd5eNpcActions")
  // Traits
  traits               Dnd5eTrait[]           @relation("Dnd5eNpcTraits")
  // Legendary Actions
  legendaryActionCount Int                    @default(0)
  // Mythic Actions are just legendary actions that think they're special, so there's a flag for that
  // mechanically they're the same they just get put in a different part of the stat block
  legendaryActions     Dnd5eLegendaryAction[] @relation("Dnd5eNpcLegendaryActions")
  // Reactions
  reactions            Dnd5eReaction[]        @relation("Dnd5eNpcReactions")
  // Lair Actions?
  // lairActions  DndLairAction[]
  // Spellcasting is a huge pain
  // these can all use tokens instead of numbers to make them reactive to stat changes
  spellAbilityMod      String?
  spellAttackMod       String?
  spellDc              String?
  // why are these different? they use different rules and it's annoying
  // because the innate spell list needs to know what spells go in what recharge list,
  // we can't just go "spells known" without duplicating data
  // so they'll just each maintain lists
  spellSlots           Dnd5eSlotSpellcasting? @relation("Dnd5eSlotSpellcasting")
  spellInnate          Dnd5eInnateSpellList[] @relation("Dnd5eInnateSpellLists")
  // where does combat tracking info go? in here?
  // both of these should reset when the npc's turn starts in combat
  reactionUsed         Boolean                @default(false)
  legendaryActionsUsed Int                    @default(0)
  // NPC
  nonPlayerCharacter   NonPlayerCharacter?    @relation("Dnd5eMonster", fields: [nonPlayerCharacterId], references: [id])
  nonPlayerCharacterId String?                @unique
}

model NonPlayerCharacter {
  id              String     @id @default(cuid())
  name            String
  notes           String     @default("")
  // Hit Points
  hitPoints       HitPoints? @relation("NonPlayerCharacterHitPoints")
  // Tokens
  tokens          Token[]    @relation("NonPlayerCharacterTokens")
  // Media
  media           Media[]    @relation("NonPlayerCharacterMedia")
  selectedMediaId String?
  // Created by
  createdBy       User       @relation("CreatedNonPlayerCharacters", fields: [createdById], references: [id])
  createdById     String
  // Controlled by
  controlledBy    User[]     @relation("ControlledNonPlayerCharacters")
  // Campaign
  campaign        Campaign   @relation("CampaignNonPlayerCharacters", fields: [campaignId], references: [id])
  campaignId      String
  // Schemas per system
  Dnd5eStats      Dnd5eNpc?  @relation("Dnd5eMonster")
  // Pf2eStats    Pf2eMonster? @relation("Pf2eMonster")
}

model Media {
  id                  String               @id @default(cuid())
  name                String
  url                 String
  thumbnailUrl        String
  width               Int
  height              Int
  size                Int
  format              String
  extension           String
  // DateTime
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @default(now()) @updatedAt
  // Avatars
  user                User[]               @relation("UserAvatar")
  // Maps
  maps                Map[]                @relation("MapMedia")
  // Player Characters
  playerCharacters    PlayerCharacter[]    @relation("PlayerCharacterMedia")
  // Non Player Characters
  nonPlayerCharacters NonPlayerCharacter[] @relation("NonPlayerCharacterMedia")
  // Created by
  createdBy           User                 @relation("UserMedia", fields: [createdById], references: [id])
  createdById         String
}

model Token {
  id                   String              @id @default(cuid())
  width                Int
  height               Int
  x                    Int
  y                    Int
  // DateTime
  createdAt            DateTime            @default(now())
  updatedAt            DateTime            @default(now()) @updatedAt
  // User
  createdBy            User                @relation("UserTokens", fields: [createdById], references: [id])
  createdById          String
  // Map
  map                  Map                 @relation("MapTokens", fields: [mapId], references: [id])
  mapId                String
  // Player Character
  playerCharacter      PlayerCharacter?    @relation("PlayerCharacterTokens", fields: [playerCharacterId], references: [id])
  playerCharacterId    String?
  // Non Player Character
  nonPlayerCharacter   NonPlayerCharacter? @relation("NonPlayerCharacterTokens", fields: [nonPlayerCharacterId], references: [id])
  nonPlayerCharacterId String?
}
